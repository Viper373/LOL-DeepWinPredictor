name: Auto Release

on:
  push:
    branches:
      - main

jobs:
  auto-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # è·å–å®Œæ•´æäº¤å†å²

      - name: Install jq for JSON parsing
        run: sudo apt-get install -y jq

      - name: Extract before and after SHAs from event
        id: extract_shas
        run: |
          # ä»äº‹ä»¶ä¸­æå– before å’Œ after çš„ commit hash
          BEFORE_SHA=$(jq -r '.before' "$GITHUB_EVENT_PATH")
          AFTER_SHA=$(jq -r '.after' "$GITHUB_EVENT_PATH")

          # å¦‚æœæ˜¯é¦–æ¬¡æ¨é€ï¼ˆbefore ä¸ºå…¨é›¶ï¼‰ï¼Œè·å–åˆå§‹æäº¤
          if [ "$BEFORE_SHA" = "0000000000000000000000000000000000000000" ]; then
            BEFORE_SHA=$(git rev-list --max-parents=0 HEAD)
          fi

          # ä¿å­˜åˆ°ç¯å¢ƒå˜é‡
          echo "BEFORE_SHA=$BEFORE_SHA" >> "$GITHUB_ENV"
          echo "AFTER_SHA=$AFTER_SHA" >> "$GITHUB_ENV"

      - name: Generate diff for entire push
        run: |
          # ç”Ÿæˆæ•´ä¸ªæ¨é€èŒƒå›´å†…çš„ diff
          git diff --patch ${{ env.BEFORE_SHA }}..${{ env.AFTER_SHA }} > changes.diff
          echo "=== Diff å†…å®¹å¦‚ä¸‹ ==="
          cat changes.diff

      - name: Get latest tag and generate next version
        id: get_tag
        run: |
          git fetch --tags
          latest_tag=$(git tag --list 'v*' --sort=-v:refname | head -n 1)
          if [ -z "$latest_tag" ]; then
            echo "tag=v1.0.0" >> "$GITHUB_OUTPUT"
          else
            IFS='.' read -r major minor patch <<< "${latest_tag#v}"
            if (( patch < 9 )); then
              patch=$((patch + 1))
            else
              patch=0
              if (( minor < 9 )); then
                minor=$((minor + 1))
              else
                minor=0
                major=$((major + 1))
              fi
            fi
            echo "tag=v$major.$minor.$patch" >> "$GITHUB_OUTPUT"
          fi

      - name: Generate AI Release Notes
        id: ai_notes
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        run: |
          set -e
          PROMPT="è¯·æ ¹æ®ä»¥ä¸‹ä»£ç å·®å¼‚ç”Ÿæˆç¬¦åˆ GitHub Release æ ‡å‡†çš„ changelogï¼Œåˆ‡è®°åªè¾“å‡ºchangelogçš„å†…å®¹å³å¯ã€‚è¦æ±‚ï¼š\n1. ä½¿ç”¨ ### åˆ†ç±»æ ‡é¢˜\n2. æ¯é¡¹æ·»åŠ åˆé€‚ emoji\n3. ç®€æ˜æ‰¼è¦æè¿°å˜æ›´\n4. ä¸è¦ä½¿ç”¨ä»£ç å—ï¼ˆä¸‰ä¸ªåå¼•å·åŒ…è£¹ï¼‰\n5. è¾“å‡ºè¯­è¨€ä¸ºä¸­æ–‡\n\nç¤ºä¾‹æ ¼å¼ï¼š\n### æ–°å¢åŠŸèƒ½\n- âœ¨ æ–°å¢äº†ç”¨æˆ·æ³¨å†ŒåŠŸèƒ½\n\n### ä¿®å¤é—®é¢˜\n- ğŸ› ä¿®å¤äº†ç™»å½•é¡µé¢çš„æ˜¾ç¤ºé—®é¢˜\n\n### ä¼˜åŒ–æ”¹è¿›\n- âš¡ ä¼˜åŒ–äº†åŠ è½½é€Ÿåº¦\n\nä»£ç å·®å¼‚ï¼š\n"
          DIFF_CONTENT=$(cat changes.diff)
          FULL_PROMPT="$PROMPT$DIFF_CONTENT"
          JSON_PROMPT=$(printf "%s" "$FULL_PROMPT" | jq -Rs .)
          cat <<EOF > request.json
          {
            "model": "x-ai/grok-4-fast:free",
            "messages": [
              {
                "role": "user",
                "content": $JSON_PROMPT
              }
            ]
          }
          EOF
          echo "==== request.json å†…å®¹å¦‚ä¸‹ ===="
          cat request.json
          response=$(curl -s https://openrouter.ai/api/v1/chat/completions  \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENROUTER_API_KEY" \
            --data-binary @request.json)
          echo "==== API response å†…å®¹å¦‚ä¸‹ ===="
          echo "$response"
          generated_notes=$(echo "$response" | jq -e -r '.choices[0].message.content') || { echo "AIè¿”å›å†…å®¹è§£æå¤±è´¥"; exit 3; }
          if [ -z "$generated_notes" ]; then
            echo "AIæœªç”Ÿæˆå†…å®¹"; exit 4;
          fi
          echo "$generated_notes" > release_note.txt

      - name: Create tag and release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git tag ${{ steps.get_tag.outputs.tag }}
          git push origin ${{ steps.get_tag.outputs.tag }}
          note="$(cat release_note.txt)"
          gh release create ${{ steps.get_tag.outputs.tag }} --notes "$note" --title "${{ steps.get_tag.outputs.tag }}"